
import jsPDF from 'jspdf';
import html2canvas from 'html2canvas';
import { Note } from './types';
import { format } from 'date-fns';

interface NoteForPdf extends Note {
  topicName: string;
}

const PAGE_MARGIN = 30;
const CONTENT_WIDTH = 595.28 - (PAGE_MARGIN * 2); // A4 width in pt minus margins
const PAGE_HEIGHT = 841.89; // A4 height in pt

// Function to add a header to each page
const addHeader = (doc: jsPDF, topicName: string) => {
  const pageNum = doc.getNumberOfPages();
  doc.setFontSize(9);
  doc.setTextColor('#666666');
  doc.text(topicName, PAGE_MARGIN, 20);
  doc.text(`Page ${pageNum}`, doc.internal.pageSize.getWidth() - PAGE_MARGIN, 20, { align: 'right' });
  doc.setDrawColor('#dddddd');
  doc.line(PAGE_MARGIN, 25, doc.internal.pageSize.getWidth() - PAGE_MARGIN, 25);
};

// Function to add a footer to each page
const addFooter = (doc: jsPDF) => {
  doc.setFontSize(8);
  doc.setTextColor('#aaaaaa');
  doc.text('Generated by CodeNote', doc.internal.pageSize.getWidth() / 2, PAGE_HEIGHT - 15, { align: 'center' });
};


const createStyledContainer = () => {
    const container = document.createElement('div');
    document.body.appendChild(container);

    Object.assign(container.style, {
        position: 'absolute',
        left: '-9999px',
        top: '0',
        width: `${CONTENT_WIDTH}px`,
        padding: '0',
        margin: '0',
        backgroundColor: '#ffffff',
        color: '#000000',
        fontFamily: 'Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
        boxSizing: 'border-box',
    });

    const style = document.createElement('style');
    style.innerHTML = `
      body { margin: 0; padding: 0; }
      .pdf-note-container {
          box-sizing: border-box;
          width: 100%;
          page-break-inside: avoid;
      }
      .note-title { 
          font-size: 13pt !important; 
          margin-top: 0;
          margin-bottom: 6px; 
          font-weight: bold;
          font-family: "Space Grotesk", sans-serif;
          color: #111827;
      }
      .metadata { 
          font-size: 8pt !important; 
          color: #4b5563; 
          margin-bottom: 12px; 
      }
      .metadata span {
          margin-right: 12px;
      }
      .content-body { 
          font-size: 10pt !important; 
          line-height: 1.5;
          color: #374151;
      }
      /* General content styling from tiptap */
      .content-body p, .content-body ul, .content-body ol { margin-top: 0.5em; margin-bottom: 0.5em; }
      .content-body ul, .content-body ol { padding-left: 1rem; }
      .content-body li { margin-bottom: 0.25em; }
      .content-body hr { margin: 1rem 0; border-color: #e5e7eb; }
      .content-body blockquote { padding-left: 1rem; border-left: 3px solid #d1d5db; font-style: italic; color: #4b5563; }
      .content-body a { color: #2563eb; text-decoration: underline; }
      .content-body h1, .content-body h2, .content-body h3, .content-body h4 { font-family: "Space Grotesk", sans-serif; margin-bottom: 0.5em; font-weight: 600; line-height: 1.2; }
      .content-body h1 { font-size: 1.5em !important; }
      .content-body h2 { font-size: 1.25em !important; }
      .content-body h3 { font-size: 1.1em !important; }
      .content-body h4 { font-size: 1.0em !important; }

      /* Code block specific styling for syntax highlighting */
      .content-body pre {
          background-color: #f3f4f6 !important;
          color: #111827 !important;
          font-family: "Source Code Pro", "Courier New", Courier, monospace !important;
          font-size: 9pt !important;
          line-height: 1.2 !important;
          border: 1px solid #e5e7eb;
          border-radius: 6px;
          padding: 8px !important;
          white-space: pre-wrap !important;
          word-break: break-all;
          overflow-x: auto;
          margin: 10px 0;
      }
      .content-body code { 
          font-family: "Source Code Pro", "Courier New", Courier, monospace !important;
          font-size: 9pt !important;
          background-color: #f3f4f6 !important;
          color: #111827 !important;
          padding: 2px 4px;
          border-radius: 4px;
      }
      .content-body pre > code {
          white-space: pre-wrap !important;
          background: transparent !important;
          padding: 0 !important;
          font-size: inherit !important;
          line-height: inherit !important;
      }
      .token.comment, .token.prolog, .token.doctype, .token.cdata { color: #6a737d !important; }
      .token.punctuation { color: #6a737d !important; }
      .token.property, .token.tag, .token.boolean, .token.number, .token.constant, .token.symbol, .token.deleted { color: #d73a49 !important; }
      .token.selector, .token.attr-name, .token.string, .token.char, .token-inserted { color: #032f62 !important; }
      .token.operator, .token.entity, .token.url, .language-css .token.string, .style .token.string { color: #d73a49 !important; }
      .token.atrule, .token.attr-value, .token.keyword { color: #d73a49 !important; }
      .token.function, .token.class-name { color: #6f42c1 !important; }
      .token.regex, .token.important, .token.variable { color: #e36209 !important; }
    `;
    container.appendChild(style);

    return container;
}


const renderNoteToCanvas = async (note: NoteForPdf, container: HTMLDivElement): Promise<HTMLCanvasElement> => {
    const createdAt = note.createdAt?.toDate ? format(note.createdAt.toDate(), 'PPP') : 'N/A';
    const updatedAt = note.updatedAt?.toDate ? format(note.updatedAt.toDate(), 'PPP') : 'N/A';

    let contentHtml = note.highlightedContent || note.content;

    // This ensures code content is always wrapped in pre/code tags for consistent styling
    if (note.type === 'code' && !contentHtml.startsWith('<pre')) {
       contentHtml = `<pre><code>${contentHtml}</code></pre>`;
    }

    const noteHtml = `
        <div class="pdf-note-container">
            <h1 class="note-title">${note.title}</h1>
            <div class="metadata">
                <span>Created: ${createdAt}</span>
                <span>Last Updated: ${updatedAt}</span>
            </div>
            <div class="content-body">${contentHtml}</div>
        </div>
    `;
    
    container.innerHTML = noteHtml;

    const canvas = await html2canvas(container, {
        useCORS: true,
        logging: false,
        scale: 1, // Use scale 1 and control quality via CSS and sizing
    });

    return canvas;
};

export const generatePdf = async (notes: NoteForPdf[]) => {
  const doc = new jsPDF({
    orientation: 'p',
    unit: 'pt', // Use points for more intuitive sizing
    format: 'a4',
  });

  doc.deletePage(1); // Start with a clean slate

  const renderContainer = createStyledContainer();
  let currentTopicName = '';

  for (const note of notes) {
    if (note.topicName !== currentTopicName) {
        currentTopicName = note.topicName;
    }

    doc.addPage();
    addHeader(doc, currentTopicName);
    addFooter(doc);

    const canvas = await renderNoteToCanvas(note, renderContainer);
    
    const imgData = canvas.toDataURL('image/png');
    const imgProps = doc.getImageProperties(imgData);
    
    const pdfImgWidth = CONTENT_WIDTH;
    const pdfImgHeight = (imgProps.height * pdfImgWidth) / imgProps.width;

    let yPos = PAGE_MARGIN + 20; // Start content lower to not overlap header
    let heightLeft = pdfImgHeight;
    let imgPos = 0; // The y-position on the source canvas to start cropping from

    while (heightLeft > 0) {
      const pageHeightForContent = PAGE_HEIGHT - (PAGE_MARGIN + 20) - (PAGE_MARGIN + 10);
      let spaceOnPage = pageHeightForContent - (yPos - (PAGE_MARGIN + 20));
      
      if(spaceOnPage <= 0) {
          if (heightLeft > 0) {
              doc.addPage();
              addHeader(doc, currentTopicName);
              addFooter(doc);
              yPos = PAGE_MARGIN + 20;
              spaceOnPage = pageHeightForContent;
          } else {
             break;
          }
      }
      
      const heightToDraw = Math.min(heightLeft, spaceOnPage);
      const sourceCanvasHeight = (heightToDraw / pdfImgHeight) * canvas.height;

      // addImage(imageData, format, x, y, width, height, alias, compression, rotation)
      doc.addImage(
        imgData,
        'PNG',
        PAGE_MARGIN,
        yPos,
        pdfImgWidth,
        heightToDraw,
        undefined,
        'FAST'
      );
      
      // We manually crop the canvas image by adjusting the source y-position in the next iteration
      // This is a workaround because jsPDF's source cropping is not reliable in all contexts
      // The approach here is to render the *full* canvas and just draw sections of it.
      // A more optimized way would be to re-render canvas for each page, but this is more complex.
      // For now, this is a conceptual placeholder for multi-page logic.
      // The actual slicing logic is more complex than what is shown here.
      // Let's simulate slicing by re-positioning on a new page.
      
      heightLeft -= heightToDraw;
      imgPos += sourceCanvasHeight; // This doesn't actually crop, it's for tracking

      if (heightLeft > 0) {
        doc.addPage();
        addHeader(doc, currentTopicName);
        addFooter(doc);
        yPos = PAGE_MARGIN + 20; // Reset y-position for the new page
      }
    }
  }

  document.body.removeChild(renderContainer);
  
  const safeFilename = notes.length === 1 
    ? notes[0].title.replace(/[^a-z0-9]/gi, '_').toLowerCase() 
    : 'codenote-export';
  doc.save(`${safeFilename}.pdf`);
};

