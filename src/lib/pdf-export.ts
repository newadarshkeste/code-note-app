import jsPDF from 'jspdf';
import html2canvas from 'html2canvas';
import { Note } from './types';
import { format } from 'date-fns';

interface NoteForPdf extends Note {
  topicName: string;
}

const PAGE_MARGIN = 30; // approx 10.5mm
const CONTENT_WIDTH = 595.28 - (PAGE_MARGIN * 2); // A4 width in pt minus margins
const PAGE_HEIGHT = 841.89; // A4 height in pt

// Function to add a header to each page
const addHeader = (doc: jsPDF, topicName: string) => {
  const pageNum = doc.getNumberOfPages();
  doc.setFontSize(9);
  doc.setTextColor('#666666');
  doc.text(topicName, PAGE_MARGIN, 20);
  doc.text(`Page ${pageNum}`, doc.internal.pageSize.getWidth() - PAGE_MARGIN, 20, { align: 'right' });
  doc.setDrawColor('#dddddd');
  doc.line(PAGE_MARGIN, 25, doc.internal.pageSize.getWidth() - PAGE_MARGIN, 25);
};

// Function to add a footer to each page
const addFooter = (doc: jsPDF) => {
  doc.setFontSize(8);
  doc.setTextColor('#aaaaaa');
  doc.text('Generated by CodeNote', doc.internal.pageSize.getWidth() / 2, PAGE_HEIGHT - 15, { align: 'center' });
};


const createStyledContainer = () => {
    const container = document.createElement('div');
    document.body.appendChild(container);

    Object.assign(container.style, {
        position: 'absolute',
        left: '-9999px',
        top: '0',
        width: `${CONTENT_WIDTH}px`,
        padding: '0',
        margin: '0',
        backgroundColor: '#ffffff',
        color: '#000000',
        fontFamily: 'Helvetica, Arial, sans-serif',
        boxSizing: 'border-box',
    });

    const style = document.createElement('style');
    style.innerHTML = `
      body { margin: 0; padding: 0; }
      .pdf-note-container {
          box-sizing: border-box;
          width: 100%;
          page-break-inside: avoid;
          font-size: 9pt;
      }
      .note-title { 
          font-size: 11pt !important; 
          margin-top: 0;
          margin-bottom: 5px; 
          font-weight: bold;
          font-family: "Helvetica", sans-serif;
          color: #111827;
      }
      .metadata { 
          font-size: 7pt !important; 
          color: #4b5563; 
          margin-bottom: 10px; 
      }
      .metadata span {
          margin-right: 12px;
      }
      .content-body { 
          font-size: 9pt !important; 
          line-height: 1.4;
          color: #374151;
      }
      /* General content styling from tiptap */
      .content-body p, .content-body ul, .content-body ol { margin-top: 0; margin-bottom: 0.4em; }
      .content-body ul, .content-body ol { padding-left: 1rem; }
      .content-body li { margin-bottom: 0.1em; }
      .content-body hr { margin: 0.8rem 0; border-color: #e5e7eb; }
      .content-body blockquote { padding-left: 1rem; border-left: 3px solid #d1d5db; font-style: italic; color: #4b5563; margin: 0.4em 0; }
      .content-body a { color: #2563eb; text-decoration: underline; }
      .content-body h1, .content-body h2, .content-body h3, .content-body h4 { font-family: "Helvetica", sans-serif; margin-bottom: 0.4em; font-weight: 600; line-height: 1.2; }
      .content-body h1 { font-size: 1.2em !important; }
      .content-body h2 { font-size: 1.1em !important; }
      .content-body h3 { font-size: 1.0em !important; }
      .content-body h4 { font-size: 0.9em !important; }

       /* This is now only for rich text */
      .content-body pre {
          display: none;
      }
    `;
    container.appendChild(style);

    return container;
}


const renderRichTextToCanvas = async (note: NoteForPdf, container: HTMLDivElement): Promise<HTMLCanvasElement> => {
    const createdAt = note.createdAt?.toDate ? format(note.createdAt.toDate(), 'PPP') : 'N/A';
    const updatedAt = note.updatedAt?.toDate ? format(note.updatedAt.toDate(), 'PPP') : 'N/A';

    let contentHtml = note.content || '';
    
    const noteElement = document.createElement('div');
    noteElement.className = 'pdf-note-container';

    noteElement.innerHTML = `
        <h1 class="note-title">${note.title}</h1>
        <div class="metadata">
            <span>Created: ${createdAt}</span>
            <span>Last Updated: ${updatedAt}</span>
        </div>
        <div class="content-body">${contentHtml}</div>
    `;
    
    container.innerHTML = ''; // Clear previous content
    container.appendChild(noteElement);

    const canvas = await html2canvas(container, {
        useCORS: true,
        logging: false,
        scale: 1.5,
    });

    return canvas;
};

export const generatePdf = async (notes: NoteForPdf[]) => {
  const doc = new jsPDF({
    orientation: 'p',
    unit: 'pt',
    format: 'a4',
  });

  const renderContainer = createStyledContainer();
  
  const sortedNotes = [...notes].sort((a, b) => {
    if (a.topicName < b.topicName) return -1;
    if (a.topicName > b.topicName) return 1;
    const dateA = a.createdAt?.toDate ? a.createdAt.toDate().getTime() : 0;
    const dateB = b.createdAt?.toDate ? b.createdAt.toDate().getTime() : 0;
    return dateA - dateB;
  });

  let yPos = PAGE_MARGIN + 20;
  let currentTopicName = '';

  // Add first page
  doc.addPage();
  doc.deletePage(1);

  for (let i = 0; i < sortedNotes.length; i++) {
    const note = sortedNotes[i];

    if (note.topicName !== currentTopicName) {
        currentTopicName = note.topicName;
        // If this isn't the very first note, add a page break for the new topic
        if (i > 0) {
            doc.addPage();
            yPos = PAGE_MARGIN + 20;
        }
    }

    // Always add headers and footers to the current (and any new) page
    doc.setPage(doc.getNumberOfPages());
    addHeader(doc, currentTopicName);
    addFooter(doc);

    const createdAt = note.createdAt?.toDate ? format(note.createdAt.toDate(), 'PPP') : 'N/A';
    const updatedAt = note.updatedAt?.toDate ? format(note.updatedAt.toDate(), 'PPP') : 'N/A';
    
    // --- RENDER TITLE AND METADATA (COMMON FOR BOTH NOTE TYPES) ---
    const titleHeight = 20;
    const metadataHeight = 15;
    const initialBlockHeight = titleHeight + metadataHeight;
    if (yPos + initialBlockHeight > PAGE_HEIGHT - PAGE_MARGIN) {
        doc.addPage();
        yPos = PAGE_MARGIN + 20;
        addHeader(doc, currentTopicName);
        addFooter(doc);
    }
    
    doc.setFont('Helvetica', 'bold');
    doc.setFontSize(11);
    doc.text(note.title, PAGE_MARGIN, yPos);
    yPos += titleHeight;

    doc.setFont('Helvetica', 'normal');
    doc.setFontSize(7);
    doc.setTextColor('#4b5563');
    doc.text(`Created: ${createdAt}    Last Updated: ${updatedAt}`, PAGE_MARGIN, yPos);
    yPos += metadataHeight;


    // --- RENDER CONTENT BASED ON TYPE ---
    if (note.type === 'code') {
        const codeLines = note.content.split('\n');
        const fontSize = 8;
        const lineHeight = 1.2;
        const codePadding = 10;
        
        doc.setFont('Courier', 'normal');
        doc.setFontSize(fontSize);
        
        // Calculate total height of the code block
        const blockHeight = (codeLines.length * fontSize * lineHeight) + (codePadding * 2);

        if (yPos + blockHeight > PAGE_HEIGHT - PAGE_MARGIN) {
            doc.addPage();
            yPos = PAGE_MARGIN + 20;
            addHeader(doc, currentTopicName);
            addFooter(doc);
        }

        // Draw background rectangle
        doc.setFillColor('#f3f4f6');
        doc.rect(PAGE_MARGIN, yPos, CONTENT_WIDTH, blockHeight, 'F');
        
        // Draw text lines
        doc.setTextColor('#111827');
        doc.text(codeLines, PAGE_MARGIN + codePadding, yPos + codePadding + fontSize, {
            lineHeightFactor: lineHeight,
            maxWidth: CONTENT_WIDTH - (codePadding * 2)
        });

        yPos += blockHeight + 20; // Move yPos down for next element

    } else { // Rich Text Note
        const canvas = await renderRichTextToCanvas(note, renderContainer);
        const imgData = canvas.toDataURL('image/png', 1.0);
        const imgProps = doc.getImageProperties(imgData);
        
        const pdfImgWidth = CONTENT_WIDTH;
        const pdfImgHeight = (imgProps.height * pdfImgWidth) / imgProps.width;

        if (yPos + pdfImgHeight > PAGE_HEIGHT - PAGE_MARGIN) {
          doc.addPage();
          yPos = PAGE_MARGIN + 20; // Reset Y for new page
          addHeader(doc, currentTopicName);
          addFooter(doc);
        }

        doc.addImage(imgData, 'PNG', PAGE_MARGIN, yPos, pdfImgWidth, pdfImgHeight);
        yPos += pdfImgHeight + 20;
    }
  }

  document.body.removeChild(renderContainer);
  
  const safeFilename = notes.length === 1 
    ? notes[0].title.replace(/[^a-z0-9]/gi, '_').toLowerCase() 
    : 'codenote-export';
  doc.save(`${safeFilename}.pdf`);
};
