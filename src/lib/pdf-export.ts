import jsPDF from 'jspdf';
import html2canvas from 'html2canvas';
import { Note } from './types';
import { format } from 'date-fns';

interface NoteForPdf extends Note {
  topicName: string;
}

const PAGE_MARGIN = 40; 
const CONTENT_WIDTH = 595.28 - (PAGE_MARGIN * 2);
const PAGE_HEIGHT = 841.89;

const addHeader = (doc: jsPDF, topicName: string) => {
  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(9);
    doc.setTextColor('#666666');
    doc.text(topicName, PAGE_MARGIN, 25);
    doc.text(`Page ${i}`, doc.internal.pageSize.getWidth() - PAGE_MARGIN, 25, { align: 'right' });
    doc.setDrawColor('#dddddd');
    doc.line(PAGE_MARGIN, 30, doc.internal.pageSize.getWidth() - PAGE_MARGIN, 30);
  }
};

const addFooter = (doc: jsPDF) => {
    const pageCount = doc.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
        doc.setPage(i);
        doc.setFontSize(8);
        doc.setTextColor('#aaaaaa');
        doc.text('Generated by CodeNote', doc.internal.pageSize.getWidth() / 2, PAGE_HEIGHT - 15, { align: 'center' });
    }
};

const createStyledContainer = () => {
  const container = document.createElement('div');
  document.body.appendChild(container);

  const style = document.createElement('style');
  style.innerHTML = `
    .pdf-render-container {
      position: absolute;
      left: -9999px;
      top: 0;
      width: ${CONTENT_WIDTH}px;
      padding: 0;
      margin: 0;
      background-color: #ffffff !important;
      color: #000000 !important;
      font-family: "Helvetica", "Arial", sans-serif;
      box-sizing: border-box;
      -webkit-print-color-adjust: exact;
    }
    .pdf-note-container {
      box-sizing: border-box;
      width: 100%;
      font-size: 10pt;
      line-height: 1.4;
      padding-bottom: 20px;
    }
    .pdf-note-container p, .pdf-note-container ul, .pdf-note-container ol { margin: 0 0 0.75em 0; }
    .pdf-note-container ul, .pdf-note-container ol { padding-left: 1.5rem; }
    .pdf-note-container h1, .pdf-note-container h2, .pdf-note-container h3, .pdf-note-container h4 { 
        font-weight: 600; 
        line-height: 1.2; 
        margin-bottom: 0.5em; 
        margin-top: 1em;
    }
    .pdf-note-container h1 { font-size: 1.4em !important; }
    .pdf-note-container h2 { font-size: 1.2em !important; }
    .pdf-note-container h3 { font-size: 1.1em !important; }
    .pdf-note-container h4 { font-size: 1.0em !important; }
    .pdf-note-container pre {
        background-color: #f3f4f6;
        padding: 8px;
        border-radius: 4px;
        white-space: pre-wrap;
        word-break: break-all;
    }
    .pdf-note-container code {
        font-family: "Source Code Pro", monospace;
        font-size: 9pt;
        line-height: 1.2;
    }
  `;
  container.appendChild(style);
  container.classList.add('pdf-render-container');
  return container;
};

export const generatePdf = async (notes: NoteForPdf[]) => {
  const doc = new jsPDF({ orientation: 'p', unit: 'pt', format: 'a4' });
  const renderContainer = createStyledContainer();

  const sortedNotes = [...notes].sort((a, b) => {
    if (a.topicName.toLowerCase() < b.topicName.toLowerCase()) return -1;
    if (a.topicName.toLowerCase() > b.topicName.toLowerCase()) return 1;
    const dateA = a.createdAt?.toDate ? a.createdAt.toDate().getTime() : 0;
    const dateB = b.createdAt?.toDate ? b.createdAt.toDate().getTime() : 0;
    return dateA - dateB;
  });

  let currentTopicName = '';
  
  // Delete the default first page
  doc.deletePage(1);

  for (let i = 0; i < sortedNotes.length; i++) {
    const note = sortedNotes[i];
    
    let yPos = PAGE_MARGIN + 20;

    if (note.topicName !== currentTopicName) {
      currentTopicName = note.topicName;
    }
    
    // Each note starts on a new page
    doc.addPage();
    yPos = PAGE_MARGIN + 20;

    addHeader(doc, currentTopicName);
    
    const createdAt = note.createdAt?.toDate ? format(note.createdAt.toDate(), 'PPP') : 'N/A';
    const updatedAt = note.updatedAt?.toDate ? format(note.updatedAt.toDate(), 'PPP') : 'N/A';

    doc.setFont('Helvetica', 'bold');
    doc.setFontSize(16);
    doc.text(note.topicName, PAGE_MARGIN, yPos);
    yPos += 20;

    doc.setFont('Helvetica', 'bold');
    doc.setFontSize(13);
    doc.text(note.title, PAGE_MARGIN, yPos);
    yPos += 18;

    doc.setFont('Helvetica', 'normal');
    doc.setFontSize(8);
    doc.setTextColor('#4b5563');
    doc.text(`Created: ${createdAt}    Last Updated: ${updatedAt}`, PAGE_MARGIN, yPos);
    yPos += 25;

    doc.setDrawColor('#dddddd');
    doc.line(PAGE_MARGIN, yPos - 15, doc.internal.pageSize.getWidth() - PAGE_MARGIN, yPos - 15);

    if (note.type === 'code') {
      const codeLines = note.content.split('\n');
      const fontSize = 8;
      const lineHeight = 1.2;
      
      const codeBlockStartY = yPos;
      
      doc.setFont("Courier", "normal");
      doc.setFontSize(fontSize);
      doc.setTextColor('#111827');
      
      const splitText = doc.splitTextToSize(note.content, CONTENT_WIDTH - 20);

      let neededHeight = splitText.length * fontSize * lineHeight;
      if (yPos + neededHeight > PAGE_HEIGHT - PAGE_MARGIN) {
        const remainingLines = doc.splitTextToSize(note.content, CONTENT_WIDTH - 20, {
            // this is a bit of a hack, but it works to split the text across pages
        });
        const linesPerPage = Math.floor((PAGE_HEIGHT - yPos - PAGE_MARGIN) / (fontSize * lineHeight));

        let lineCursor = 0;
        while(lineCursor < remainingLines.length) {
            const chunk = remainingLines.slice(lineCursor, lineCursor + linesPerPage);
            doc.setFillColor('#f3f4f6');
            doc.rect(PAGE_MARGIN - 5, yPos - 10, CONTENT_WIDTH + 10, (chunk.length * fontSize * lineHeight) + 15, 'F');
            doc.text(chunk, PAGE_MARGIN + 5, yPos);
            yPos += (chunk.length * fontSize * lineHeight) + 20;
            lineCursor += linesPerPage;

            if (lineCursor < remainingLines.length) {
                doc.addPage();
                yPos = PAGE_MARGIN + 20;
                addHeader(doc, currentTopicName);
            }
        }
      } else {
         doc.setFillColor('#f3f4f6');
         doc.rect(PAGE_MARGIN - 5, codeBlockStartY - 10, CONTENT_WIDTH + 10, neededHeight + 15, 'F');
         doc.text(splitText, PAGE_MARGIN + 5, codeBlockStartY);
      }

    } else { // Rich Text Note
      const noteElement = document.createElement('div');
      noteElement.className = 'pdf-note-container';
      noteElement.innerHTML = note.content || '';
      renderContainer.innerHTML = '';
      renderContainer.appendChild(noteElement);
      
      const canvas = await html2canvas(renderContainer, { 
          useCORS: true, 
          logging: false, 
          scale: 2, 
          width: CONTENT_WIDTH,
          windowWidth: CONTENT_WIDTH,
        });

      const imgData = canvas.toDataURL('image/png', 1.0);
      const imgProps = doc.getImageProperties(imgData);
      
      const pdfImgWidth = CONTENT_WIDTH;
      const pdfImgHeight = (imgProps.height * pdfImgWidth) / imgProps.width;

      let remainingHeight = pdfImgHeight;
      let imgY = 0;

      while (remainingHeight > 0) {
        const pageRemainingHeight = PAGE_HEIGHT - yPos - PAGE_MARGIN;
        const drawableHeight = Math.min(remainingHeight, pageRemainingHeight);

        doc.addImage(imgData, 'PNG', PAGE_MARGIN, yPos, pdfImgWidth, pdfImgHeight, undefined, 'FAST', -imgY);

        remainingHeight -= drawableHeight;
        imgY += drawableHeight;
        
        if (remainingHeight > 0) {
          doc.addPage();
          yPos = PAGE_MARGIN;
          addHeader(doc, currentTopicName);
        }
      }
    }
  }

  addFooter(doc);
  document.body.removeChild(renderContainer);
  
  const safeFilename = notes.length === 1 
    ? notes[0].title.replace(/[^a-z0-9]/gi, '_').toLowerCase() 
    : 'codenote-export';
  doc.save(`${safeFilename}.pdf`);
};
