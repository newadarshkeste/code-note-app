
import jsPDF from 'jspdf';
import html2canvas from 'html2canvas';
import { Note } from './types';
import { format } from 'date-fns';

interface NoteForPdf extends Note {
  topicName: string;
}

const PAGE_MARGIN = 40;
const CONTENT_WIDTH = 595.28 - (PAGE_MARGIN * 2);
const PAGE_HEIGHT = 841.89;

// --------------------- HEADER ------------------------
const addHeader = (doc: jsPDF, pageNumber: number) => {
  doc.setPage(pageNumber);
  doc.setFontSize(9);
  doc.setTextColor('#666');
  doc.text(`Page ${pageNumber}`, 595.28 - PAGE_MARGIN, 25, { align: 'right' });
  doc.setDrawColor('#ddd');
  doc.line(PAGE_MARGIN, 30, 595.28 - PAGE_MARGIN, 30);
};

// --------------------- FOOTER ------------------------
const addFooter = (doc: jsPDF) => {
    const pageCount = doc.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
        doc.setPage(i);
        doc.setFontSize(8);
        doc.setTextColor('#aaa');
        doc.text('Generated by CodeNote', 595.28 / 2, PAGE_HEIGHT - 15, { align: 'center' });
    }
};

// ----------------- HTML CANVAS CONTAINER -------------
const createStyledContainer = () => {
  const container = document.createElement('div');
  container.classList.add("pdf-render-container");
  document.body.appendChild(container);

  if (!document.getElementById('pdf-style')) {
    const style = document.createElement("style");
    style.id = 'pdf-style';
    style.innerHTML = `
      .pdf-render-container {
        position: absolute;
        left: -9999px;
        top: 0;
        width: ${CONTENT_WIDTH}px;
        padding: 0;
        margin: 0;
        background: white;
        font-family: 'Helvetica', 'Arial', sans-serif;
        color: black;
        -webkit-print-color-adjust: exact;
      }
      .pdf-note-container {
        font-size: 8pt;
        line-height: 1.4;
        width: 100%;
        background: #fff;
      }
      .pdf-note-container p { margin: 0 0 8px 0; font-size: 8pt; }
      .pdf-note-container h1 { font-size: 14pt; margin: 0 0 10px 0; }
      .pdf-note-container h2 { font-size: 12pt; margin: 0 0 8px 0; }
      .pdf-note-container h3 { font-size: 11pt; margin: 0 0 6px 0; }
      .pdf-note-container pre {
        background: #f3f4f6;
        padding: 8px;
        border-radius: 4px;
        white-space: pre-wrap;
        word-break: break-all;
        margin: 0;
      }
      .pdf-note-container code {
        font-family: "Source Code Pro", "Courier New", monospace;
        font-size: 8pt;
        line-height: 1.2;
        color: #000;
      }
      .pdf-note-container ul, .pdf-note-container ol { margin-left: 20px; margin-bottom: 8px; }
      .pdf-note-container blockquote { border-left: 2px solid #ccc; padding-left: 10px; margin-left: 0; }
    `;
    document.head.appendChild(style);
  }

  return container;
};

const cleanupContainer = (container: HTMLElement) => {
    if (container.parentNode) {
        container.parentNode.removeChild(container);
    }
};

// ----------------- MAIN EXPORT FUNCTION ---------------
export const generatePdf = async (notes: NoteForPdf[]) => {
  const doc = new jsPDF({ orientation: 'p', unit: 'pt', format: 'a4' });
  const container = createStyledContainer();

  const sortedNotes = [...notes].sort((a, b) => {
    if (a.topicName.toLowerCase() < b.topicName.toLowerCase()) return -1;
    if (a.topicName.toLowerCase() > b.topicName.toLowerCase()) return 1;
    const dateA = a.createdAt?.toDate ? a.createdAt.toDate().getTime() : 0;
    const dateB = b.createdAt?.toDate ? b.createdAt.toDate().getTime() : 0;
    return dateA - dateB;
  });
  
  doc.addPage();
  doc.deletePage(1);

  let yPos = PAGE_MARGIN;
  let currentTopicName = '';

  for (let i = 0; i < sortedNotes.length; i++) {
    const note = sortedNotes[i];
    
    // --- Add a new page if content won't fit ---
    // Estimate height. This is a rough guess; adjust as needed.
    const noteHeightEstimate = (note.content?.split('\n').length || 1) * 10 + 80;
    if (yPos + noteHeightEstimate > PAGE_HEIGHT - PAGE_MARGIN && i > 0) {
        doc.addPage();
        yPos = PAGE_MARGIN;
        // Don't repeat topic header if it's the same
    }
    
    // --- Topic Header ---
    if(note.topicName !== currentTopicName) {
        currentTopicName = note.topicName;
        yPos += (yPos === PAGE_MARGIN ? 0 : 30); // Add space before new topic unless at top of page
        doc.setFont("Helvetica", "bold");
        doc.setFontSize(16);
        doc.text(currentTopicName, PAGE_MARGIN, yPos);
        yPos += 25;
    }

    // -------- Note Title + Metadata ----------
    const created = note.createdAt?.toDate ? format(note.createdAt.toDate(), 'PPP') : 'N/A';
    const updated = note.updatedAt?.toDate ? format(note.updatedAt.toDate(), 'PPP') : 'N/A';
    
    doc.setFont("Helvetica", "bold");
    doc.setFontSize(13);
    doc.text(note.title, PAGE_MARGIN, yPos);
    yPos += 18;

    doc.setFont("Helvetica", "normal");
    doc.setFontSize(8);
    doc.setTextColor("#444");
    doc.text(`Created: ${created}     Updated: ${updated}`, PAGE_MARGIN, yPos);
    yPos += 15;

    // ========== CODE NOTE (Plain Text) ==========
    if (note.type === "code") {
      const codeLines = doc.splitTextToSize(note.content || '', CONTENT_WIDTH - 10);
      const codeBlockHeight = codeLines.length * 8 * 1.2 + 10;

      // Check for page break before drawing code block
      if (yPos + codeBlockHeight > PAGE_HEIGHT - PAGE_MARGIN) {
          doc.addPage();
          yPos = PAGE_MARGIN;
      }

      doc.setFillColor("#f3f4f6");
      doc.rect(PAGE_MARGIN, yPos, CONTENT_WIDTH, codeBlockHeight, "F");

      doc.setFont("Courier", "normal");
      doc.setFontSize(8);
      doc.setTextColor("#000");
      doc.text(codeLines, PAGE_MARGIN + 5, yPos + 10, { lineHeightFactor: 1.2 });
      yPos += codeBlockHeight + 15; // Spacing after note
    
    } else {
    // ============ RICH TEXT NOTE (CANVAS) ============
      const elem = document.createElement("div");
      elem.className = "pdf-note-container";
      // This is a simple way to render the HTML, assuming it's safe and sanitized
      elem.innerHTML = note.content; 
      container.innerHTML = "";
      container.appendChild(elem);

      const canvas = await html2canvas(container, { scale: 2, width: CONTENT_WIDTH, windowWidth: CONTENT_WIDTH });
      const imgData = canvas.toDataURL("image/png");
      
      // FIX: Check if image data is valid before adding
      if (imgData && imgData !== 'data:,') {
        const imgProps = doc.getImageProperties(imgData);
        const pdfImgWidth = CONTENT_WIDTH;
        const pdfImgHeight = (imgProps.height * pdfImgWidth) / imgProps.width;

        if (yPos + pdfImgHeight > PAGE_HEIGHT - PAGE_MARGIN) {
          doc.addPage();
          yPos = PAGE_MARGIN;
        }

        doc.addImage(imgData, "PNG", PAGE_MARGIN, yPos, pdfImgWidth, pdfImgHeight, undefined, 'FAST');
        yPos += pdfImgHeight + 15; // Spacing after note
      } else {
        // If canvas is empty, maybe add a fallback text
        doc.setFont("Helvetica", "italic");
        doc.setFontSize(8);
        doc.setTextColor("#888");
        doc.text("[Note content could not be rendered]", PAGE_MARGIN, yPos);
        yPos += 20;
      }
    }
  }

  // Add headers and footers to all pages at the end
  const pageCount = doc.getNumberOfPages();
  for(let i = 1; i <= pageCount; i++) {
    addHeader(doc, i);
  }
  addFooter(doc);

  cleanupContainer(container);
  
  const filename = notes.length === 1 && notes[0].title
    ? notes[0].title.replace(/[^a-z0-9]/gi, "_").toLowerCase()
    : "codenote-export";
  
  doc.save(filename + ".pdf");
};
